<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live GLTF Projection</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Space Grotesk", system-ui, sans-serif;
      background: #f4efe6;
      color: #2c1f16;
    }
    header {
      padding: 18px 24px;
      background: #fffdf7;
      border-bottom: 1px solid #e2d7c7;
    }
    header h1 {
      margin: 0 0 6px;
      font-size: 1.6rem;
    }
    header p {
      margin: 0;
      color: #5a4a3e;
    }
    main {
      display: grid;
      grid-template-columns: minmax(320px, 520px) minmax(300px, 1fr);
      gap: 18px;
      padding: 18px 24px 28px;
    }
    .panel {
      background: #fffdf7;
      border: 1px solid #e2d7c7;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 20px rgba(44, 31, 22, 0.06);
    }
    .status {
      display: flex;
      gap: 12px;
      font-size: 0.9rem;
      color: #5a4a3e;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    canvas {
      width: 100%;
      height: 420px;
      background: #fdf8ef;
      border-radius: 10px;
      border: 1px solid #e2d7c7;
    }
    textarea {
      width: 100%;
      height: 420px;
      font-family: "IBM Plex Mono", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.85rem;
      border-radius: 10px;
      border: 1px solid #e2d7c7;
      padding: 12px;
      background: #fbf7f0;
      color: #3a2a1d;
    }
    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    .actions a,
    .actions button {
      border: 1px solid #2c1f16;
      background: #2c1f16;
      color: #fffaf0;
      border-radius: 999px;
      padding: 8px 14px;
      text-decoration: none;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .actions button.secondary {
      background: transparent;
      color: #2c1f16;
    }
    @media (max-width: 920px) {
      main { grid-template-columns: 1fr; }
      canvas, textarea { height: 320px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Live GLTF Projection</h1>
    <p>Events → SVG → GLTF (live). JSON stays canonical; preview is a projection.</p>
    <div class="status">
      <span id="transport">transport: connecting</span>
      <span id="event-count">events: 0</span>
      <span id="last-update">last update: —</span>
    </div>
  </header>
  <main>
    <section class="panel">
      <h2>GLTF Preview</h2>
      <canvas id="preview" width="520" height="420"></canvas>
      <div class="actions">
        <a id="download" href="#" download="live-export.gltf">Download GLTF</a>
        <button id="refresh" class="secondary">Force Rebuild</button>
      </div>
    </section>
    <section class="panel">
      <h2>GLTF JSON</h2>
      <textarea id="gltf-json" readonly spellcheck="false"></textarea>
    </section>
  </main>
  <script type="module">
    import { createSession } from "/lib/session.js";
    import { renderSvg } from "/lib/svg-render.js";
    import { svgToGltf } from "/lib/svg-gltf.js";

    const canvas = document.getElementById("preview");
    const ctx = canvas.getContext("2d");
    const transportEl = document.getElementById("transport");
    const countEl = document.getElementById("event-count");
    const updateEl = document.getElementById("last-update");
    const jsonEl = document.getElementById("gltf-json");
    const downloadEl = document.getElementById("download");
    const refreshButton = document.getElementById("refresh");

    const session = createSession();
    const events = [];
    let gltfJson = {};
    let svgText = "";
    let dirty = false;

    function updateStatus() {
      transportEl.textContent = `transport: ${session.status || "unknown"}`;
      countEl.textContent = `events: ${events.length}`;
    }

    function scheduleBuild() {
      if (dirty) return;
      dirty = true;
      requestAnimationFrame(() => {
        dirty = false;
        rebuild();
      });
    }

    function rebuild() {
      svgText = renderSvg(events, { animate: false });
      gltfJson = svgToGltf(svgText);
      jsonEl.value = JSON.stringify(gltfJson, null, 2);
      const blob = new Blob([jsonEl.value], { type: "model/gltf+json" });
      downloadEl.href = URL.createObjectURL(blob);
      updateEl.textContent = `last update: ${new Date().toLocaleTimeString()}`;
      renderPreview(svgText);
    }

    function parseShapes(svg) {
      const shapes = [];
      const rectRe = /<rect\\b[^>]*>/g;
      const lineRe = /<line\\b[^>]*>/g;

      const parseAttrs = (raw) => {
        const attrs = {};
        const re = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)="([^"]*)"/g;
        let match;
        while ((match = re.exec(raw))) {
          attrs[match[1]] = match[2];
        }
        return attrs;
      };

      const collect = (re, kind) => {
        let match;
        while ((match = re.exec(svg))) {
          const raw = match[0];
          const attrs = parseAttrs(raw);
          shapes.push({ kind, attrs, classes: (attrs.class || "").split(/\\s+/) });
        }
      };

      collect(rectRe, "rect");
      collect(lineRe, "line");
      return shapes;
    }

    function projectPoint(x, y, z, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const xr = x * cos - z * sin;
      const zr = x * sin + z * cos;
      const scale = 0.7 + zr * 0.002;
      return [xr * scale, y * scale];
    }

    function renderPreview(svg) {
      const shapes = parseShapes(svg);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fdf8ef";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const angle = Date.now() * 0.0004;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      shapes.forEach((shape) => {
        const isNode = shape.classes.includes("node");
        const isSelected = shape.classes.includes("selected");
        const isRemoved = shape.classes.includes("removed");
        const color = isSelected ? "#a24b2d" : "#2c1f16";
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.globalAlpha = isRemoved ? 0.25 : 1;

        if (shape.kind === "line") {
          const x1 = Number(shape.attrs.x1 || 0);
          const y1 = Number(shape.attrs.y1 || 0);
          const x2 = Number(shape.attrs.x2 || 0);
          const y2 = Number(shape.attrs.y2 || 0);
          const p1 = projectPoint(x1 - 260, y1 - 210, 0, angle);
          const p2 = projectPoint(x2 - 260, y2 - 210, 0, angle);
          ctx.beginPath();
          ctx.moveTo(cx + p1[0], cy + p1[1]);
          ctx.lineTo(cx + p2[0], cy + p2[1]);
          ctx.stroke();
          return;
        }

        const x = Number(shape.attrs.x || 0) + 4;
        const y = Number(shape.attrs.y || 0) + 4;
        const z = isNode ? 20 : 0;
        const p = projectPoint(x - 260, y - 210, z, angle);
        ctx.beginPath();
        ctx.arc(cx + p[0], cy + p[1], 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function onEvent(evt) {
      events.push(evt);
      updateStatus();
      scheduleBuild();
    }

    session.on(onEvent);
    session.connect();
    updateStatus();
    rebuild();

    refreshButton.addEventListener("click", rebuild);
    setInterval(updateStatus, 1200);
  </script>
</body>
</html>
